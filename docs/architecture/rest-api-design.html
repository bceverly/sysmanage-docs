<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>REST API Design - SysManage Architecture</title>
    <meta name="description" content="REST API design patterns, endpoint structure, authentication, error handling, and best practices in SysManage.">
    <link rel="stylesheet" href="../../assets/css/style.css">
    <link rel="icon" type="image/svg+xml" href="../../assets/images/favicon.svg">
</head>
<body>
    <header class="site-header">
        <nav class="navbar">
            <div class="container">
                <div class="nav-brand">
                    <a href="../../">
                        <img src="../../assets/images/sysmanage-logo.svg" alt="SysManage" class="logo">
                    </a>
                </div>
                <div class="nav-menu">
                    <a href="../../#features" class="nav-link" data-i18n="nav.features">Features</a>
                    <a href="../../#getting-started" class="nav-link" data-i18n="nav.getting_started">Getting Started</a>
                    <a href="../" class="nav-link active" data-i18n="nav.documentation">Documentation</a>
                    <a href="../../config-builder.html" class="nav-link" data-i18n="nav.config_builder">Configuration Builder</a>
                    <a href="https://github.com/bceverly/sysmanage" class="nav-link" target="_blank" data-i18n="nav.github">GitHub</a>
                </div>
            </div>
        </nav>
    </header>

    <main class="docs-main">
        <div class="container">
            <div class="docs-breadcrumb">
                <a href="../">Documentation</a> > <a href="./">Architecture</a> > <span>REST API Design</span>
            </div>

            <div class="docs-header">
                <h1>REST API Design</h1>
                <p>REST API design patterns, endpoint structure, authentication, error handling, and best practices in SysManage.</p>
            </div>

            <div class="docs-content">
                <section class="overview">
                    <h2>API Design Philosophy</h2>
                    <p>SysManage's REST API follows industry best practices and RESTful principles to provide a consistent, intuitive, and powerful interface for system management operations. The API is designed to be self-documenting, version-safe, and developer-friendly.</p>

                    <div class="design-principles">
                        <h3>Core Design Principles</h3>
                        <div class="principles-grid">
                            <div class="principle-card">
                                <h4>ğŸ¯ Resource-Oriented</h4>
                                <p>URLs represent resources, not actions. Clear resource hierarchy with logical nesting.</p>
                            </div>
                            <div class="principle-card">
                                <h4>ğŸ”’ Security First</h4>
                                <p>Authentication, authorization, and input validation on every endpoint.</p>
                            </div>
                            <div class="principle-card">
                                <h4>ğŸ“Š Consistent Responses</h4>
                                <p>Standardized response formats, error codes, and pagination across all endpoints.</p>
                            </div>
                            <div class="principle-card">
                                <h4>ğŸ“ˆ Performance Optimized</h4>
                                <p>Efficient queries, caching, rate limiting, and bulk operations support.</p>
                            </div>
                            <div class="principle-card">
                                <h4>ğŸ”„ Version Safe</h4>
                                <p>Backward compatibility, gradual deprecation, and clear migration paths.</p>
                            </div>
                            <div class="principle-card">
                                <h4>ğŸ“ Self-Documenting</h4>
                                <p>OpenAPI specification, comprehensive examples, and interactive documentation.</p>
                            </div>
                        </div>
                    </div>

                    <div class="api-overview">
                        <h3>API Architecture Overview</h3>
                        <pre class="ascii-diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        API Gateway                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Rate        â”‚  â”‚ Auth &      â”‚  â”‚ Request Validation      â”‚ â”‚
â”‚  â”‚ Limiting    â”‚  â”‚ AuthZ       â”‚  â”‚ & Sanitization          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     API Routing Layer                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ /api/v1/    â”‚  â”‚ /api/v1/    â”‚  â”‚ /api/v1/                â”‚ â”‚
â”‚  â”‚ auth        â”‚  â”‚ agents      â”‚  â”‚ tasks                   â”‚ â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚                         â”‚ â”‚
â”‚  â”‚ â€¢ login     â”‚  â”‚ â€¢ CRUD ops  â”‚  â”‚ â€¢ CRUD ops              â”‚ â”‚
â”‚  â”‚ â€¢ logout    â”‚  â”‚ â€¢ actions   â”‚  â”‚ â€¢ execution             â”‚ â”‚
â”‚  â”‚ â€¢ refresh   â”‚  â”‚ â€¢ metrics   â”‚  â”‚ â€¢ scheduling            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ /api/v1/    â”‚  â”‚ /api/v1/    â”‚  â”‚ /api/v1/                â”‚ â”‚
â”‚  â”‚ inventory   â”‚  â”‚ config      â”‚  â”‚ metrics                 â”‚ â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚                         â”‚ â”‚
â”‚  â”‚ â€¢ packages  â”‚  â”‚ â€¢ settings  â”‚  â”‚ â€¢ collection            â”‚ â”‚
â”‚  â”‚ â€¢ services  â”‚  â”‚ â€¢ policies  â”‚  â”‚ â€¢ aggregation           â”‚ â”‚
â”‚  â”‚ â€¢ hardware  â”‚  â”‚ â€¢ templates â”‚  â”‚ â€¢ alerts                â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                               â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  Business Logic     â”‚
                    â”‚  Layer              â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                               â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  Data Access        â”‚
                    â”‚  Layer              â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        </pre>
                    </div>
                </section>

                <section class="url-structure">
                    <h2>URL Structure & Resource Hierarchy</h2>

                    <div class="url-patterns">
                        <h3>URL Convention</h3>
                        <p>SysManage follows a consistent URL pattern that clearly expresses resource relationships:</p>

                        <div class="url-format">
                            <pre class="url-example">
https://api.sysmanage.example.com/api/v1/{resource}[/{id}][/{sub-resource}][/{sub-id}]

Examples:
GET    /api/v1/agents                           # List all agents
GET    /api/v1/agents/123                       # Get specific agent
GET    /api/v1/agents/123/packages              # List packages on agent
POST   /api/v1/agents/123/tasks                 # Create task for agent
GET    /api/v1/agents/123/tasks/456             # Get specific task
PUT    /api/v1/agents/123/tasks/456/cancel      # Cancel specific task
                            </pre>
                        </div>

                        <h3>Resource Hierarchy</h3>
                        <div class="resource-tree">
                            <pre class="ascii-diagram">
/api/v1/
â”œâ”€â”€ auth/                           # Authentication endpoints
â”‚   â”œâ”€â”€ login                       # POST: User login
â”‚   â”œâ”€â”€ logout                      # POST: User logout
â”‚   â”œâ”€â”€ refresh                     # POST: Token refresh
â”‚   â””â”€â”€ profile                     # GET/PUT: User profile
â”‚
â”œâ”€â”€ agents/                         # Agent management
â”‚   â”œâ”€â”€ {id}/                       # Specific agent operations
â”‚   â”‚   â”œâ”€â”€ packages/               # Package inventory
â”‚   â”‚   â”œâ”€â”€ services/               # Service status
â”‚   â”‚   â”œâ”€â”€ tasks/                  # Agent-specific tasks
â”‚   â”‚   â”œâ”€â”€ metrics/                # Agent metrics
â”‚   â”‚   â””â”€â”€ actions/                # Agent actions (reboot, etc.)
â”‚   â”‚       â”œâ”€â”€ reboot
â”‚   â”‚       â”œâ”€â”€ shutdown
â”‚   â”‚       â””â”€â”€ update-agent
â”‚   â””â”€â”€ groups/                     # Agent grouping
â”‚       â”œâ”€â”€ {id}/
â”‚       â””â”€â”€ {id}/members/
â”‚
â”œâ”€â”€ tasks/                          # Task management
â”‚   â”œâ”€â”€ {id}/                       # Specific task operations
â”‚   â”‚   â”œâ”€â”€ cancel                  # POST: Cancel task
â”‚   â”‚   â”œâ”€â”€ retry                   # POST: Retry failed task
â”‚   â”‚   â”œâ”€â”€ logs                    # GET: Task execution logs
â”‚   â”‚   â””â”€â”€ artifacts/              # Task output artifacts
â”‚   â”œâ”€â”€ schedules/                  # Scheduled tasks
â”‚   â”‚   â”œâ”€â”€ {id}/
â”‚   â”‚   â””â”€â”€ {id}/executions/
â”‚   â””â”€â”€ templates/                  # Task templates
â”‚       â””â”€â”€ {id}/
â”‚
â”œâ”€â”€ inventory/                      # System inventory
â”‚   â”œâ”€â”€ packages/                   # Package management
â”‚   â”‚   â”œâ”€â”€ search                  # GET: Search packages
â”‚   â”‚   â”œâ”€â”€ updates                 # GET: Available updates
â”‚   â”‚   â””â”€â”€ vulnerabilities         # GET: Security issues
â”‚   â”œâ”€â”€ services/                   # Service management
â”‚   â”‚   â””â”€â”€ {name}/                 # Specific service
â”‚   â””â”€â”€ hardware/                   # Hardware inventory
â”‚       â”œâ”€â”€ cpu/
â”‚       â”œâ”€â”€ memory/
â”‚       â””â”€â”€ storage/
â”‚
â”œâ”€â”€ metrics/                        # Metrics and monitoring
â”‚   â”œâ”€â”€ query                       # POST: Custom metric queries
â”‚   â”œâ”€â”€ dashboards/                 # Dashboard management
â”‚   â”‚   â””â”€â”€ {id}/
â”‚   â””â”€â”€ alerts/                     # Alert management
â”‚       â”œâ”€â”€ {id}/
â”‚       â”œâ”€â”€ rules/                  # Alert rules
â”‚       â””â”€â”€ notifications/          # Notification channels
â”‚
â”œâ”€â”€ config/                         # Configuration management
â”‚   â”œâ”€â”€ settings/                   # System settings
â”‚   â”œâ”€â”€ policies/                   # Security policies
â”‚   â”‚   â””â”€â”€ {id}/
â”‚   â””â”€â”€ certificates/               # Certificate management
â”‚       â”œâ”€â”€ {id}/
â”‚       â”œâ”€â”€ ca/                     # Certificate Authority
â”‚       â””â”€â”€ revoked/                # Revoked certificates
â”‚
â””â”€â”€ admin/                          # Administrative endpoints
    â”œâ”€â”€ users/                      # User management
    â”‚   â”œâ”€â”€ {id}/
    â”‚   â””â”€â”€ {id}/roles/
    â”œâ”€â”€ roles/                      # Role management
    â”‚   â””â”€â”€ {id}/
    â”œâ”€â”€ audit/                      # Audit logs
    â””â”€â”€ system/                     # System status
        â”œâ”€â”€ health                  # Health check
        â”œâ”€â”€ version                 # Version info
        â””â”€â”€ status                  # System status
                            </pre>
                        </div>
                    </div>

                    <div class="http-methods">
                        <h3>HTTP Method Usage</h3>
                        <div class="method-grid">
                            <div class="method-card">
                                <h4>GET</h4>
                                <p><strong>Purpose:</strong> Retrieve resources</p>
                                <ul>
                                    <li>Safe and idempotent</li>
                                    <li>Cacheable responses</li>
                                    <li>No request body</li>
                                    <li>Supports filtering and pagination</li>
                                </ul>
                                <pre class="example">
GET /api/v1/agents?status=online&limit=50&offset=0
GET /api/v1/agents/123/packages?search=nginx
                                </pre>
                            </div>

                            <div class="method-card">
                                <h4>POST</h4>
                                <p><strong>Purpose:</strong> Create resources or trigger actions</p>
                                <ul>
                                    <li>Not idempotent</li>
                                    <li>Request body contains data</li>
                                    <li>Returns 201 for creation, 200 for actions</li>
                                </ul>
                                <pre class="example">
POST /api/v1/agents/123/tasks
POST /api/v1/agents/123/actions/reboot
POST /api/v1/auth/login
                                </pre>
                            </div>

                            <div class="method-card">
                                <h4>PUT</h4>
                                <p><strong>Purpose:</strong> Replace entire resource</p>
                                <ul>
                                    <li>Idempotent</li>
                                    <li>Complete resource replacement</li>
                                    <li>Creates if doesn't exist</li>
                                </ul>
                                <pre class="example">
PUT /api/v1/agents/123
PUT /api/v1/config/settings/email
                                </pre>
                            </div>

                            <div class="method-card">
                                <h4>PATCH</h4>
                                <p><strong>Purpose:</strong> Partial resource updates</p>
                                <ul>
                                    <li>Idempotent</li>
                                    <li>Partial modifications</li>
                                    <li>JSON Patch or merge semantics</li>
                                </ul>
                                <pre class="example">
PATCH /api/v1/agents/123
PATCH /api/v1/tasks/456
                                </pre>
                            </div>

                            <div class="method-card">
                                <h4>DELETE</h4>
                                <p><strong>Purpose:</strong> Remove resources</p>
                                <ul>
                                    <li>Idempotent</li>
                                    <li>No request body</li>
                                    <li>Returns 204 on success</li>
                                </ul>
                                <pre class="example">
DELETE /api/v1/agents/123
DELETE /api/v1/tasks/456
                                </pre>
                            </div>
                        </div>
                    </div>
                </section>

                <section class="authentication-authorization">
                    <h2>Authentication & Authorization</h2>

                    <div class="auth-flow">
                        <h3>Authentication Flow</h3>
                        <pre class="ascii-diagram">
Client                     Auth Server                 API Server
  â”‚                           â”‚                           â”‚
  â”‚ 1. Login Request          â”‚                           â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚                           â”‚
  â”‚   POST /api/v1/auth/login â”‚                           â”‚
  â”‚   { username, password }   â”‚                           â”‚
  â”‚                           â”‚                           â”‚
  â”‚ 2. Validate Credentials   â”‚                           â”‚
  â”‚                           â”‚ â† â† â† â† â† â† â† â† â† â† â† â† â”‚
  â”‚                           â”‚   Check User Database     â”‚
  â”‚                           â”‚                           â”‚
  â”‚ 3. JWT Tokens             â”‚                           â”‚
  â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚                           â”‚
  â”‚   { access_token,         â”‚                           â”‚
  â”‚     refresh_token }       â”‚                           â”‚
  â”‚                           â”‚                           â”‚
  â”‚ 4. API Request            â”‚                           â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚
  â”‚   GET /api/v1/agents      â”‚                           â”‚
  â”‚   Authorization: Bearer   â”‚                           â”‚
  â”‚   {access_token}          â”‚                           â”‚
  â”‚                           â”‚                           â”‚
  â”‚                           â”‚ 5. Validate Token         â”‚
  â”‚                           â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
  â”‚                           â”‚                           â”‚
  â”‚ 6. API Response           â”‚                           â”‚
  â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
  â”‚   { agents: [...] }       â”‚                           â”‚
                        </pre>

                        <h4>JWT Token Structure</h4>
                        <pre class="json-example">
{
  "header": {
    "alg": "RS256",
    "typ": "JWT",
    "kid": "sysmanage-2024-01"
  },
  "payload": {
    "iss": "sysmanage.example.com",
    "sub": "user-123",
    "aud": "sysmanage-api",
    "exp": 1642694400,
    "iat": 1642608000,
    "jti": "token-uuid-123",
    "user_id": 123,
    "username": "admin",
    "roles": ["admin", "operator"],
    "permissions": {
      "agents": ["read", "write", "delete"],
      "tasks": ["read", "write", "execute"],
      "metrics": ["read"],
      "admin": ["read", "write"]
    },
    "session_id": "session-uuid-456"
  }
}
                        </pre>

                        <h4>Token Management Implementation</h4>
                        <pre class="code-example">
# FastAPI authentication implementation
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer
from jose import JWTError, jwt
from datetime import datetime, timedelta

security = HTTPBearer()

class AuthenticationService:
    def __init__(self, secret_key: str, algorithm: str = "RS256"):
        self.secret_key = secret_key
        self.algorithm = algorithm
        self.access_token_expire_minutes = 15
        self.refresh_token_expire_days = 30

    async def authenticate_user(self, username: str, password: str) -> Optional[User]:
        """Authenticate user credentials"""
        user = await get_user_by_username(username)
        if not user or not verify_password(password, user.password_hash):
            return None
        return user

    def create_access_token(self, user: User) -> str:
        """Create JWT access token"""
        expire = datetime.utcnow() + timedelta(minutes=self.access_token_expire_minutes)

        payload = {
            "iss": "sysmanage.example.com",
            "sub": str(user.id),
            "aud": "sysmanage-api",
            "exp": expire,
            "iat": datetime.utcnow(),
            "jti": str(uuid.uuid4()),
            "user_id": user.id,
            "username": user.username,
            "roles": [role.name for role in user.roles],
            "permissions": await self.get_user_permissions(user),
            "session_id": str(uuid.uuid4())
        }

        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)

    def create_refresh_token(self, user: User) -> str:
        """Create JWT refresh token"""
        expire = datetime.utcnow() + timedelta(days=self.refresh_token_expire_days)

        payload = {
            "iss": "sysmanage.example.com",
            "sub": str(user.id),
            "aud": "sysmanage-refresh",
            "exp": expire,
            "iat": datetime.utcnow(),
            "jti": str(uuid.uuid4()),
            "token_type": "refresh"
        }

        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)

    async def verify_token(self, token: str) -> dict:
        """Verify and decode JWT token"""
        try:
            payload = jwt.decode(
                token,
                self.secret_key,
                algorithms=[self.algorithm],
                audience="sysmanage-api"
            )

            # Check if token is expired
            if datetime.utcnow() > datetime.fromtimestamp(payload['exp']):
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Token expired"
                )

            # Check if session is still valid
            if not await self.is_session_valid(payload['session_id']):
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Session invalid"
                )

            return payload

        except JWTError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token"
            )

# Dependency for requiring authentication
async def get_current_user(token: str = Depends(security)) -> User:
    """Get current authenticated user"""
    auth_service = get_auth_service()
    payload = await auth_service.verify_token(token.credentials)

    user = await get_user_by_id(payload['user_id'])
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found"
        )

    return user

# Role-based authorization decorator
def require_permission(resource: str, action: str):
    def decorator(func):
        async def wrapper(*args, **kwargs):
            user = kwargs.get('current_user')
            if not user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Authentication required"
                )

            if not await user.has_permission(resource, action):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail=f"Permission denied: {action} on {resource}"
                )

            return await func(*args, **kwargs)
        return wrapper
    return decorator

# Usage in API endpoints
@app.post("/api/v1/auth/login")
async def login(credentials: LoginCredentials):
    user = await auth_service.authenticate_user(
        credentials.username,
        credentials.password
    )

    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials"
        )

    access_token = auth_service.create_access_token(user)
    refresh_token = auth_service.create_refresh_token(user)

    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer",
        "expires_in": auth_service.access_token_expire_minutes * 60
    }

@app.get("/api/v1/agents")
@require_permission("agents", "read")
async def list_agents(
    current_user: User = Depends(get_current_user),
    limit: int = 50,
    offset: int = 0
):
    return await agent_service.list_agents(
        user=current_user,
        limit=limit,
        offset=offset
    )
                        </pre>
                    </div>

                    <div class="rbac-system">
                        <h3>Role-Based Access Control (RBAC)</h3>

                        <h4>Permission Model</h4>
                        <div class="permission-hierarchy">
                            <pre class="ascii-diagram">
Permissions Hierarchy:

Organization
â”œâ”€â”€ Global Admin
â”‚   â”œâ”€â”€ All Resources: [create, read, update, delete, execute]
â”‚   â””â”€â”€ All Administrative Functions
â”‚
â”œâ”€â”€ Team Admin
â”‚   â”œâ”€â”€ Team Agents: [create, read, update, delete]
â”‚   â”œâ”€â”€ Team Tasks: [create, read, update, execute]
â”‚   â””â”€â”€ Team Users: [read, update]
â”‚
â”œâ”€â”€ Operator
â”‚   â”œâ”€â”€ Assigned Agents: [read, update]
â”‚   â”œâ”€â”€ Tasks: [create, read, execute]
â”‚   â””â”€â”€ Metrics: [read]
â”‚
â”œâ”€â”€ Read-Only User
â”‚   â”œâ”€â”€ Assigned Agents: [read]
â”‚   â”œâ”€â”€ Tasks: [read]
â”‚   â””â”€â”€ Metrics: [read]
â”‚
â””â”€â”€ Service Account
    â”œâ”€â”€ API Access: [specific endpoints]
    â””â”€â”€ Automated Tasks: [execute]
                            </pre>
                        </div>

                        <h4>Permission Checking Implementation</h4>
                        <pre class="code-example">
# Permission checking system
class PermissionChecker:
    def __init__(self, user: User):
        self.user = user
        self.permissions = self._load_user_permissions()

    def _load_user_permissions(self) -> dict:
        """Load user permissions from roles and direct assignments"""
        permissions = {}

        # Aggregate permissions from all roles
        for role in self.user.roles:
            for resource, actions in role.permissions.items():
                if resource not in permissions:
                    permissions[resource] = set()
                permissions[resource].update(actions)

        # Add direct user permissions
        for resource, actions in self.user.direct_permissions.items():
            if resource not in permissions:
                permissions[resource] = set()
            permissions[resource].update(actions)

        return permissions

    async def can_access_resource(self, resource_type: str, resource_id: str,
                                action: str) -> bool:
        """Check if user can perform action on specific resource"""

        # Check global permissions
        if self.has_global_permission(resource_type, action):
            return True

        # Check resource-specific permissions
        return await self.has_resource_permission(
            resource_type, resource_id, action
        )

    def has_global_permission(self, resource_type: str, action: str) -> bool:
        """Check if user has global permission for resource type"""
        return (resource_type in self.permissions and
                action in self.permissions[resource_type])

    async def has_resource_permission(self, resource_type: str,
                                   resource_id: str, action: str) -> bool:
        """Check resource-specific permissions (team/group based)"""

        if resource_type == "agents":
            agent = await get_agent_by_id(resource_id)
            if not agent:
                return False

            # Check if user has access to agent's group
            for role in self.user.roles:
                if role.scope_type == "group" and role.scope_id == agent.group_id:
                    return action in role.permissions.get("agents", [])

            # Check if user is assigned to specific agent
            return await self.is_user_assigned_to_agent(self.user.id, resource_id)

        elif resource_type == "tasks":
            task = await get_task_by_id(resource_id)
            if not task:
                return False

            # Check if user created the task or is assigned to it
            if task.created_by == self.user.id or task.assigned_to == self.user.id:
                return True

            # Check agent permissions for the task's target agent
            if task.agent_id:
                return await self.has_resource_permission(
                    "agents", str(task.agent_id), action
                )

        return False

# Middleware for automatic permission checking
@app.middleware("http")
async def permission_middleware(request: Request, call_next):
    # Skip permission checks for public endpoints
    if request.url.path in PUBLIC_ENDPOINTS:
        return await call_next(request)

    # Extract resource type and ID from URL
    path_parts = request.url.path.strip('/').split('/')
    if len(path_parts) >= 4 and path_parts[0] == 'api' and path_parts[1] == 'v1':
        resource_type = path_parts[2]
        resource_id = path_parts[3] if len(path_parts) > 3 else None

        # Get current user from token
        user = await get_current_user_from_request(request)
        if not user:
            return JSONResponse(
                status_code=401,
                content={"error": "Authentication required"}
            )

        # Map HTTP method to action
        action_map = {
            "GET": "read",
            "POST": "create",
            "PUT": "update",
            "PATCH": "update",
            "DELETE": "delete"
        }
        action = action_map.get(request.method, "read")

        # Check permissions
        checker = PermissionChecker(user)
        if resource_id:
            has_permission = await checker.can_access_resource(
                resource_type, resource_id, action
            )
        else:
            has_permission = checker.has_global_permission(resource_type, action)

        if not has_permission:
            return JSONResponse(
                status_code=403,
                content={
                    "error": "Permission denied",
                    "details": f"Action '{action}' not allowed on '{resource_type}'"
                }
            )

    return await call_next(request)
                        </pre>
                    </div>
                </section>

                <section class="response-formats">
                    <h2>Response Formats & Standards</h2>

                    <div class="response-structure">
                        <h3>Standard Response Format</h3>
                        <p>All API responses follow a consistent structure for predictable client integration:</p>

                        <h4>Success Response Structure</h4>
                        <pre class="json-example">
{
  "success": true,
  "data": {
    // Actual response data
  },
  "meta": {
    "timestamp": "2024-01-15T10:30:00Z",
    "request_id": "req-123e4567-e89b-12d3-a456-426614174000",
    "api_version": "1.0",
    "execution_time_ms": 45
  },
  "pagination": {  // Only for paginated responses
    "page": 1,
    "per_page": 50,
    "total": 247,
    "total_pages": 5,
    "has_next": true,
    "has_prev": false
  }
}
                        </pre>

                        <h4>Error Response Structure</h4>
                        <pre class="json-example">
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid input provided",
    "details": [
      {
        "field": "agent_id",
        "message": "Agent ID must be a positive integer",
        "value": "invalid-id"
      }
    ],
    "help_url": "https://docs.sysmanage.com/api/errors#validation-error"
  },
  "meta": {
    "timestamp": "2024-01-15T10:30:00Z",
    "request_id": "req-123e4567-e89b-12d3-a456-426614174000",
    "api_version": "1.0"
  }
}
                        </pre>

                        <h4>Response Implementation</h4>
                        <pre class="code-example">
# Response formatting utilities
from typing import Any, Optional, Dict, List
from pydantic import BaseModel
from datetime import datetime
import time
import uuid

class PaginationMeta(BaseModel):
    page: int
    per_page: int
    total: int
    total_pages: int
    has_next: bool
    has_prev: bool

class ResponseMeta(BaseModel):
    timestamp: datetime
    request_id: str
    api_version: str
    execution_time_ms: Optional[int] = None

class ErrorDetail(BaseModel):
    field: Optional[str] = None
    message: str
    value: Optional[Any] = None

class ErrorInfo(BaseModel):
    code: str
    message: str
    details: Optional[List[ErrorDetail]] = None
    help_url: Optional[str] = None

class APIResponse(BaseModel):
    success: bool
    data: Optional[Any] = None
    error: Optional[ErrorInfo] = None
    meta: ResponseMeta
    pagination: Optional[PaginationMeta] = None

class ResponseBuilder:
    def __init__(self, request_id: str = None):
        self.request_id = request_id or str(uuid.uuid4())
        self.start_time = time.time()

    def success(self, data: Any = None, pagination: PaginationMeta = None) -> dict:
        """Build successful response"""
        execution_time = int((time.time() - self.start_time) * 1000)

        response = APIResponse(
            success=True,
            data=data,
            meta=ResponseMeta(
                timestamp=datetime.utcnow(),
                request_id=self.request_id,
                api_version="1.0",
                execution_time_ms=execution_time
            ),
            pagination=pagination
        )

        return response.dict(exclude_none=True)

    def error(self, code: str, message: str, details: List[ErrorDetail] = None,
              status_code: int = 400) -> dict:
        """Build error response"""

        help_url = f"https://docs.sysmanage.com/api/errors#{code.lower().replace('_', '-')}"

        response = APIResponse(
            success=False,
            error=ErrorInfo(
                code=code,
                message=message,
                details=details,
                help_url=help_url
            ),
            meta=ResponseMeta(
                timestamp=datetime.utcnow(),
                request_id=self.request_id,
                api_version="1.0"
            )
        )

        return response.dict(exclude_none=True)

# FastAPI response formatting middleware
@app.middleware("http")
async def response_formatting_middleware(request: Request, call_next):
    # Generate request ID
    request_id = str(uuid.uuid4())
    request.state.request_id = request_id
    request.state.start_time = time.time()

    # Add request ID to response headers
    response = await call_next(request)
    response.headers["X-Request-ID"] = request_id

    return response

# Usage in API endpoints
@app.get("/api/v1/agents/{agent_id}")
async def get_agent(
    agent_id: int,
    request: Request,
    current_user: User = Depends(get_current_user)
):
    builder = ResponseBuilder(request.state.request_id)

    try:
        # Validate agent ID
        if agent_id <= 0:
            return JSONResponse(
                status_code=400,
                content=builder.error(
                    code="INVALID_AGENT_ID",
                    message="Agent ID must be a positive integer",
                    details=[ErrorDetail(
                        field="agent_id",
                        message="Must be greater than 0",
                        value=agent_id
                    )]
                )
            )

        # Get agent
        agent = await agent_service.get_agent(agent_id, current_user)
        if not agent:
            return JSONResponse(
                status_code=404,
                content=builder.error(
                    code="AGENT_NOT_FOUND",
                    message=f"Agent with ID {agent_id} not found"
                )
            )

        # Return success response
        return builder.success(data=agent.dict())

    except PermissionError:
        return JSONResponse(
            status_code=403,
            content=builder.error(
                code="PERMISSION_DENIED",
                message="You don't have permission to access this agent"
            )
        )
    except Exception as e:
        logger.error(f"Unexpected error in get_agent: {e}")
        return JSONResponse(
            status_code=500,
            content=builder.error(
                code="INTERNAL_ERROR",
                message="An unexpected error occurred"
            )
        )
                        </pre>
                    </div>

                    <div class="pagination">
                        <h3>Pagination Standards</h3>

                        <h4>Pagination Parameters</h4>
                        <ul>
                            <li><strong>limit:</strong> Number of items per page (max 100, default 50)</li>
                            <li><strong>offset:</strong> Number of items to skip (default 0)</li>
                            <li><strong>sort:</strong> Sort field and direction (e.g., "created_at:desc")</li>
                            <li><strong>filter:</strong> Filter parameters (resource-specific)</li>
                        </ul>

                        <h4>Pagination Links</h4>
                        <pre class="json-example">
{
  "success": true,
  "data": {
    "agents": [
      // ... agent objects
    ]
  },
  "pagination": {
    "page": 2,
    "per_page": 50,
    "total": 247,
    "total_pages": 5,
    "has_next": true,
    "has_prev": true,
    "links": {
      "first": "/api/v1/agents?limit=50&offset=0",
      "prev": "/api/v1/agents?limit=50&offset=0",
      "self": "/api/v1/agents?limit=50&offset=50",
      "next": "/api/v1/agents?limit=50&offset=100",
      "last": "/api/v1/agents?limit=50&offset=200"
    }
  }
}
                        </pre>

                        <h4>Filtering and Sorting</h4>
                        <pre class="url-example">
# Filtering examples
GET /api/v1/agents?status=online&platform=linux&group_id=5
GET /api/v1/tasks?status=running&created_after=2024-01-01&agent_id=123
GET /api/v1/packages?name=nginx&version_gt=1.20

# Sorting examples
GET /api/v1/agents?sort=hostname:asc
GET /api/v1/tasks?sort=created_at:desc,priority:asc
GET /api/v1/metrics?sort=timestamp:desc&limit=100

# Complex queries
GET /api/v1/agents?search=web-server&status=online&sort=last_seen:desc&limit=25
                        </pre>
                    </div>
                </section>

                <section class="error-handling">
                    <h2>Error Handling</h2>

                    <div class="error-system">
                        <h3>HTTP Status Codes</h3>
                        <div class="status-codes">
                            <div class="status-category">
                                <h4>2xx Success</h4>
                                <ul>
                                    <li><strong>200 OK:</strong> Successful GET, PUT, PATCH, or action</li>
                                    <li><strong>201 Created:</strong> Successful POST that creates resource</li>
                                    <li><strong>202 Accepted:</strong> Async operation started</li>
                                    <li><strong>204 No Content:</strong> Successful DELETE or empty result</li>
                                </ul>
                            </div>

                            <div class="status-category">
                                <h4>4xx Client Errors</h4>
                                <ul>
                                    <li><strong>400 Bad Request:</strong> Invalid request format or parameters</li>
                                    <li><strong>401 Unauthorized:</strong> Authentication required or invalid</li>
                                    <li><strong>403 Forbidden:</strong> Permission denied</li>
                                    <li><strong>404 Not Found:</strong> Resource doesn't exist</li>
                                    <li><strong>409 Conflict:</strong> Resource state conflict</li>
                                    <li><strong>422 Unprocessable Entity:</strong> Validation errors</li>
                                    <li><strong>429 Too Many Requests:</strong> Rate limit exceeded</li>
                                </ul>
                            </div>

                            <div class="status-category">
                                <h4>5xx Server Errors</h4>
                                <ul>
                                    <li><strong>500 Internal Server Error:</strong> Unexpected server error</li>
                                    <li><strong>502 Bad Gateway:</strong> Upstream service error</li>
                                    <li><strong>503 Service Unavailable:</strong> Temporary unavailability</li>
                                    <li><strong>504 Gateway Timeout:</strong> Upstream timeout</li>
                                </ul>
                            </div>
                        </div>

                        <h3>Error Code System</h3>
                        <div class="error-codes">
                            <h4>Error Code Categories</h4>
                            <pre class="error-code-table">
Category         | Prefix | Examples
-----------------|--------|------------------------------------------
Authentication   | AUTH_  | AUTH_INVALID_TOKEN, AUTH_EXPIRED_TOKEN
Authorization    | PERM_  | PERM_DENIED, PERM_INSUFFICIENT
Validation       | VAL_   | VAL_REQUIRED_FIELD, VAL_INVALID_FORMAT
Resource         | RES_   | RES_NOT_FOUND, RES_ALREADY_EXISTS
Business Logic   | BIZ_   | BIZ_AGENT_OFFLINE, BIZ_TASK_ALREADY_RUNNING
External         | EXT_   | EXT_DATABASE_ERROR, EXT_SERVICE_UNAVAILABLE
Rate Limiting    | RATE_  | RATE_LIMIT_EXCEEDED, RATE_QUOTA_EXCEEDED
System           | SYS_   | SYS_MAINTENANCE, SYS_OVERLOADED
                            </pre>

                            <h4>Validation Error Examples</h4>
                            <pre class="json-example">
{
  "success": false,
  "error": {
    "code": "VAL_MULTIPLE_ERRORS",
    "message": "Multiple validation errors occurred",
    "details": [
      {
        "field": "hostname",
        "message": "Hostname is required",
        "value": null
      },
      {
        "field": "platform",
        "message": "Platform must be one of: linux, windows, macos, bsd",
        "value": "unknown"
      },
      {
        "field": "ip_address",
        "message": "Invalid IP address format",
        "value": "192.168.1"
      }
    ]
  }
}
                            </pre>
                        </div>

                        <h4>Error Handling Implementation</h4>
                        <pre class="code-example">
# Custom exception classes
class APIException(Exception):
    def __init__(self, code: str, message: str, status_code: int = 400,
                 details: List[ErrorDetail] = None):
        self.code = code
        self.message = message
        self.status_code = status_code
        self.details = details or []
        super().__init__(message)

class ValidationError(APIException):
    def __init__(self, details: List[ErrorDetail]):
        super().__init__(
            code="VAL_MULTIPLE_ERRORS" if len(details) > 1 else "VAL_ERROR",
            message="Validation error" + ("s" if len(details) > 1 else ""),
            status_code=422,
            details=details
        )

class NotFoundError(APIException):
    def __init__(self, resource: str, identifier: str):
        super().__init__(
            code="RES_NOT_FOUND",
            message=f"{resource} with identifier '{identifier}' not found",
            status_code=404
        )

class PermissionDeniedError(APIException):
    def __init__(self, action: str, resource: str):
        super().__init__(
            code="PERM_DENIED",
            message=f"Permission denied: {action} on {resource}",
            status_code=403
        )

# Global exception handler
@app.exception_handler(APIException)
async def api_exception_handler(request: Request, exc: APIException):
    builder = ResponseBuilder(getattr(request.state, 'request_id', None))

    return JSONResponse(
        status_code=exc.status_code,
        content=builder.error(
            code=exc.code,
            message=exc.message,
            details=exc.details
        )
    )

@app.exception_handler(ValidationException)
async def validation_exception_handler(request: Request, exc: ValidationException):
    builder = ResponseBuilder(getattr(request.state, 'request_id', None))

    details = [
        ErrorDetail(
            field=error['loc'][-1] if error['loc'] else None,
            message=error['msg'],
            value=error.get('input')
        )
        for error in exc.errors()
    ]

    return JSONResponse(
        status_code=422,
        content=builder.error(
            code="VAL_MULTIPLE_ERRORS",
            message="Request validation failed",
            details=details
        )
    )

@app.exception_handler(500)
async def internal_error_handler(request: Request, exc: Exception):
    builder = ResponseBuilder(getattr(request.state, 'request_id', None))

    # Log the full exception for debugging
    logger.error(f"Internal server error: {exc}", exc_info=True)

    return JSONResponse(
        status_code=500,
        content=builder.error(
            code="SYS_INTERNAL_ERROR",
            message="An internal server error occurred"
        )
    )

# Rate limiting error handler
@app.exception_handler(RateLimitExceeded)
async def rate_limit_handler(request: Request, exc: RateLimitExceeded):
    builder = ResponseBuilder(getattr(request.state, 'request_id', None))

    return JSONResponse(
        status_code=429,
        content=builder.error(
            code="RATE_LIMIT_EXCEEDED",
            message=f"Rate limit exceeded: {exc.limit} requests per {exc.window}"
        ),
        headers={
            "X-RateLimit-Limit": str(exc.limit),
            "X-RateLimit-Remaining": str(exc.remaining),
            "X-RateLimit-Reset": str(exc.reset_time)
        }
    )
                        </pre>
                    </div>
                </section>

                <section class="versioning-deprecation">
                    <h2>API Versioning & Deprecation</h2>

                    <div class="versioning-strategy">
                        <h3>Versioning Strategy</h3>

                        <h4>URL-based Versioning</h4>
                        <p>SysManage uses URL path versioning for clear, explicit version identification:</p>

                        <pre class="url-example">
# Current version
https://api.sysmanage.example.com/api/v1/agents

# Future version
https://api.sysmanage.example.com/api/v2/agents

# Version-specific features
https://api.sysmanage.example.com/api/v1/agents          # Basic agent management
https://api.sysmanage.example.com/api/v2/agents          # Enhanced with grouping
https://api.sysmanage.example.com/api/v3/agents          # AI-powered insights
                        </pre>

                        <h4>Backward Compatibility</h4>
                        <div class="compatibility-rules">
                            <div class="rule">
                                <h5>âœ… Non-Breaking Changes (Within Version)</h5>
                                <ul>
                                    <li>Adding optional request parameters</li>
                                    <li>Adding fields to response objects</li>
                                    <li>Adding new endpoints</li>
                                    <li>Adding new optional headers</li>
                                    <li>Adding new enum values (with default handling)</li>
                                </ul>
                            </div>

                            <div class="rule">
                                <h5>âŒ Breaking Changes (Require New Version)</h5>
                                <ul>
                                    <li>Removing or renaming fields</li>
                                    <li>Changing field types or formats</li>
                                    <li>Making optional parameters required</li>
                                    <li>Changing endpoint URLs</li>
                                    <li>Changing authentication mechanisms</li>
                                    <li>Removing endpoints</li>
                                </ul>
                            </div>
                        </div>

                        <h4>Deprecation Process</h4>
                        <pre class="ascii-diagram">
Version Release Timeline:

v1.0 Released â”€â”€â”€â”€â”€â”€â”€â”€â–¶ v2.0 Released â”€â”€â”€â”€â”€â”€â”€â”€â–¶ v1.0 Deprecated â”€â”€â”€â”€â–¶ v1.0 Removed
     â”‚                       â”‚                       â”‚                     â”‚
     â”‚ â—€â”€â”€â”€â”€ 18 months â”€â”€â”€â”€â–¶ â”‚ â—€â”€â”€â”€â”€ 6 months â”€â”€â”€â”€â–¶ â”‚ â—€â”€â”€â”€ 6 months â”€â”€â”€â–¶ â”‚
     â”‚                       â”‚                       â”‚                     â”‚
   Active                 Maintenance             Deprecated           Unsupported
   Support                   Only                  Warning
                                                   Headers

Phase 1: Active Support (18 months)
- Full feature development
- Bug fixes and security updates
- Performance optimizations

Phase 2: Maintenance Only (6 months)
- Security updates only
- Critical bug fixes
- Deprecation warnings added

Phase 3: Deprecated (6 months)
- No updates except security
- Strong deprecation warnings
- Migration guides published

Phase 4: Removed
- API version no longer available
- 410 Gone responses
                        </pre>

                        <h4>Deprecation Headers</h4>
                        <pre class="http-example">
# Deprecation warning headers
HTTP/1.1 200 OK
Deprecation: true
Sunset: Wed, 11 Nov 2024 23:59:59 GMT
Link: &lt;https://docs.sysmanage.com/api/v2/migration&gt;; rel="successor-version"
Warning: 299 - "This API version is deprecated. Please migrate to v2 by November 2024"

{
  "success": true,
  "data": { ... },
  "meta": {
    "deprecation_notice": {
      "deprecated": true,
      "sunset_date": "2024-11-11T23:59:59Z",
      "migration_guide": "https://docs.sysmanage.com/api/v2/migration",
      "contact": "api-support@sysmanage.com"
    }
  }
}
                        </pre>

                        <h4>Version Management Implementation</h4>
                        <pre class="code-example">
# API version management
from enum import Enum
from datetime import datetime, timezone

class APIVersion(Enum):
    V1 = "v1"
    V2 = "v2"

class VersionInfo:
    def __init__(self, version: APIVersion, status: str, sunset_date: datetime = None):
        self.version = version
        self.status = status  # active, maintenance, deprecated, removed
        self.sunset_date = sunset_date

# Version configuration
VERSION_CONFIG = {
    APIVersion.V1: VersionInfo(
        version=APIVersion.V1,
        status="deprecated",
        sunset_date=datetime(2024, 11, 11, 23, 59, 59, tzinfo=timezone.utc)
    ),
    APIVersion.V2: VersionInfo(
        version=APIVersion.V2,
        status="active"
    )
}

# Version extraction middleware
@app.middleware("http")
async def version_middleware(request: Request, call_next):
    # Extract version from URL path
    path_parts = request.url.path.strip('/').split('/')
    if len(path_parts) >= 3 and path_parts[0] == 'api':
        version_str = path_parts[1]
        try:
            api_version = APIVersion(version_str)
            request.state.api_version = api_version

            # Check if version is still supported
            version_info = VERSION_CONFIG.get(api_version)
            if not version_info:
                return JSONResponse(
                    status_code=400,
                    content={"error": f"Unsupported API version: {version_str}"}
                )

            if version_info.status == "removed":
                return JSONResponse(
                    status_code=410,
                    content={
                        "error": "This API version has been removed",
                        "migration_guide": "https://docs.sysmanage.com/api/v2/migration"
                    }
                )

            request.state.version_info = version_info

        except ValueError:
            return JSONResponse(
                status_code=400,
                content={"error": f"Invalid API version: {version_str}"}
            )

    response = await call_next(request)

    # Add deprecation headers if needed
    if hasattr(request.state, 'version_info'):
        version_info = request.state.version_info
        if version_info.status in ["maintenance", "deprecated"]:
            response.headers["Deprecation"] = "true"

            if version_info.sunset_date:
                response.headers["Sunset"] = version_info.sunset_date.strftime(
                    "%a, %d %b %Y %H:%M:%S GMT"
                )

            if version_info.status == "deprecated":
                response.headers["Warning"] = (
                    "299 - \"This API version is deprecated. "
                    "Please migrate to the latest version.\""
                )

    return response

# Version-specific endpoint handling
class VersionedEndpoint:
    def __init__(self):
        self.handlers = {}

    def version(self, api_version: APIVersion):
        def decorator(func):
            self.handlers[api_version] = func
            return func
        return decorator

    async def handle(self, request: Request, *args, **kwargs):
        api_version = getattr(request.state, 'api_version', APIVersion.V1)
        handler = self.handlers.get(api_version)

        if not handler:
            # Fall back to latest version or return not supported
            latest_version = max(self.handlers.keys(), key=lambda v: v.value)
            handler = self.handlers[latest_version]

        return await handler(request, *args, **kwargs)

# Usage example
agents_endpoint = VersionedEndpoint()

@agents_endpoint.version(APIVersion.V1)
async def get_agents_v1(request: Request, current_user: User = Depends(get_current_user)):
    """Legacy agent list format"""
    agents = await agent_service.list_agents(current_user)
    return {
        "agents": [
            {
                "id": agent.id,
                "hostname": agent.hostname,
                "status": agent.status,
                "last_seen": agent.last_seen
            }
            for agent in agents
        ]
    }

@agents_endpoint.version(APIVersion.V2)
async def get_agents_v2(request: Request, current_user: User = Depends(get_current_user)):
    """Enhanced agent list with grouping and metadata"""
    agents = await agent_service.list_agents_with_groups(current_user)
    return {
        "agents": [
            {
                "id": agent.id,
                "hostname": agent.hostname,
                "status": agent.status,
                "last_seen": agent.last_seen,
                "group": {
                    "id": agent.group.id,
                    "name": agent.group.name
                } if agent.group else None,
                "metadata": agent.metadata,
                "health_score": agent.health_score
            }
            for agent in agents
        ],
        "summary": {
            "total": len(agents),
            "online": sum(1 for a in agents if a.status == "online"),
            "groups": len(set(a.group_id for a in agents if a.group_id))
        }
    }

@app.get("/api/{version}/agents")
async def list_agents(request: Request):
    return await agents_endpoint.handle(request)
                        </pre>
                    </div>
                </section>

                <section class="performance-optimization">
                    <h2>Performance Optimization</h2>

                    <div class="optimization-strategies">
                        <h3>Caching Strategy</h3>

                        <h4>Multi-Level Caching</h4>
                        <pre class="ascii-diagram">
Client Request â†’ CDN Cache â†’ API Gateway Cache â†’ Application Cache â†’ Database
     â”‚              â”‚              â”‚                    â”‚              â”‚
     â–¼              â–¼              â–¼                    â–¼              â–¼
Static Assets   API Responses  Auth Tokens        Query Results   Raw Data
(Images, JS)    (1-5 minutes)  (15 minutes)      (30 seconds)    (Source)
TTL: 1 hour     TTL: Variable  TTL: Token Life   TTL: Variable   TTL: N/A
                        </pre>

                        <h4>Caching Implementation</h4>
                        <pre class="code-example">
# Multi-level caching system
import redis
from functools import wraps
import json
import hashlib
from typing import Any, Optional

class CacheManager:
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.default_ttl = 300  # 5 minutes

    def generate_cache_key(self, prefix: str, *args, **kwargs) -> str:
        """Generate cache key from function arguments"""
        key_data = {
            'args': args,
            'kwargs': sorted(kwargs.items())
        }
        key_hash = hashlib.md5(json.dumps(key_data, sort_keys=True).encode()).hexdigest()
        return f"{prefix}:{key_hash}"

    async def get(self, key: str) -> Optional[Any]:
        """Get value from cache"""
        try:
            value = await self.redis.get(key)
            return json.loads(value) if value else None
        except Exception as e:
            logger.warning(f"Cache get error: {e}")
            return None

    async def set(self, key: str, value: Any, ttl: int = None) -> bool:
        """Set value in cache"""
        try:
            ttl = ttl or self.default_ttl
            serialized = json.dumps(value, default=str)
            return await self.redis.setex(key, ttl, serialized)
        except Exception as e:
            logger.warning(f"Cache set error: {e}")
            return False

    async def delete(self, pattern: str) -> int:
        """Delete keys matching pattern"""
        try:
            keys = await self.redis.keys(pattern)
            if keys:
                return await self.redis.delete(*keys)
            return 0
        except Exception as e:
            logger.warning(f"Cache delete error: {e}")
            return 0

    def cached(self, prefix: str, ttl: int = None,
               invalidate_on: list = None):
        """Decorator for caching function results"""
        def decorator(func):
            @wraps(func)
            async def wrapper(*args, **kwargs):
                # Generate cache key
                cache_key = self.generate_cache_key(prefix, *args, **kwargs)

                # Try to get from cache
                cached_result = await self.get(cache_key)
                if cached_result is not None:
                    return cached_result

                # Execute function
                result = await func(*args, **kwargs)

                # Cache the result
                await self.set(cache_key, result, ttl)

                return result
            return wrapper
        return decorator

# Cache usage in API endpoints
cache_manager = CacheManager(redis_client)

@app.get("/api/v1/agents")
@cache_manager.cached("agents_list", ttl=60)  # 1 minute cache
async def list_agents(
    current_user: User = Depends(get_current_user),
    status: Optional[str] = None,
    limit: int = 50,
    offset: int = 0
):
    return await agent_service.list_agents(
        user=current_user,
        status=status,
        limit=limit,
        offset=offset
    )

@app.get("/api/v1/agents/{agent_id}")
@cache_manager.cached("agent_detail", ttl=30)  # 30 second cache
async def get_agent(
    agent_id: int,
    current_user: User = Depends(get_current_user)
):
    return await agent_service.get_agent(agent_id, current_user)

# Cache invalidation on updates
@app.put("/api/v1/agents/{agent_id}")
async def update_agent(
    agent_id: int,
    agent_data: AgentUpdate,
    current_user: User = Depends(get_current_user)
):
    # Update agent
    updated_agent = await agent_service.update_agent(
        agent_id, agent_data, current_user
    )

    # Invalidate related caches
    await cache_manager.delete(f"agent_detail:*{agent_id}*")
    await cache_manager.delete("agents_list:*")

    return updated_agent
                        </pre>

                        <h3>Database Query Optimization</h3>

                        <h4>Query Patterns</h4>
                        <pre class="code-example">
# Optimized database queries
from sqlalchemy.orm import selectinload, joinedload
from sqlalchemy import and_, or_, func

class OptimizedAgentService:
    def __init__(self, db_session):
        self.db = db_session

    async def list_agents_with_stats(self, user: User, filters: dict = None):
        """Optimized agent listing with statistics"""

        # Base query with necessary joins
        query = (
            select(Agent)
            .options(
                joinedload(Agent.group),  # Avoid N+1 queries for groups
                selectinload(Agent.packages).options(
                    # Only load package counts, not full objects
                    load_only(Package.id, Package.status)
                )
            )
            .where(Agent.deleted_at.is_(None))  # Soft delete filter
        )

        # Apply user-based permissions
        accessible_agent_ids = await self.get_accessible_agent_ids(user)
        if accessible_agent_ids:
            query = query.where(Agent.id.in_(accessible_agent_ids))

        # Apply filters efficiently
        if filters:
            if 'status' in filters:
                query = query.where(Agent.status == filters['status'])

            if 'platform' in filters:
                query = query.where(Agent.platform == filters['platform'])

            if 'search' in filters:
                search_term = f"%{filters['search']}%"
                query = query.where(
                    or_(
                        Agent.hostname.ilike(search_term),
                        Agent.ip_address.cast(String).like(search_term)
                    )
                )

        # Get total count efficiently (without loading all data)
        count_query = select(func.count(Agent.id)).select_from(
            query.subquery()
        )
        total_count = await self.db.scalar(count_query)

        # Apply pagination
        if 'limit' in filters:
            query = query.limit(filters['limit'])
        if 'offset' in filters:
            query = query.offset(filters['offset'])

        # Execute query
        result = await self.db.execute(query)
        agents = result.unique().scalars().all()

        # Calculate statistics in a single query
        stats = await self.get_agent_statistics(accessible_agent_ids)

        return {
            'agents': agents,
            'total': total_count,
            'statistics': stats
        }

    async def get_agent_statistics(self, agent_ids: List[int]):
        """Get agent statistics in a single optimized query"""

        stats_query = (
            select(
                Agent.status,
                func.count(Agent.id).label('count'),
                func.avg(Agent.cpu_usage).label('avg_cpu'),
                func.avg(Agent.memory_usage).label('avg_memory')
            )
            .where(Agent.id.in_(agent_ids))
            .group_by(Agent.status)
        )

        result = await self.db.execute(stats_query)
        stats_by_status = {row.status: {
            'count': row.count,
            'avg_cpu': row.avg_cpu,
            'avg_memory': row.avg_memory
        } for row in result}

        return {
            'by_status': stats_by_status,
            'total': sum(s['count'] for s in stats_by_status.values()),
            'online': stats_by_status.get('online', {}).get('count', 0)
        }

# Bulk operations for efficiency
class BulkOperations:
    def __init__(self, db_session):
        self.db = db_session

    async def bulk_update_agent_status(self, agent_updates: List[dict]):
        """Efficiently update multiple agents"""

        # Use bulk update for better performance
        stmt = (
            update(Agent)
            .where(Agent.id == bindparam('agent_id'))
            .values(
                status=bindparam('status'),
                last_seen=bindparam('last_seen'),
                updated_at=func.now()
            )
        )

        await self.db.execute(stmt, agent_updates)
        await self.db.commit()

    async def bulk_create_metrics(self, metrics: List[dict]):
        """Efficiently insert multiple metrics"""

        # Use bulk insert with ON CONFLICT handling
        stmt = insert(Metric).values(metrics)

        # Handle conflicts for duplicate timestamps
        stmt = stmt.on_conflict_do_update(
            index_elements=['agent_id', 'metric_name', 'timestamp'],
            set_={
                'value': stmt.excluded.value,
                'updated_at': func.now()
            }
        )

        await self.db.execute(stmt)
        await self.db.commit()
                        </pre>

                        <h3>Rate Limiting</h3>

                        <h4>Adaptive Rate Limiting</h4>
                        <pre class="code-example">
# Advanced rate limiting implementation
from typing import Dict, Optional
import time
import asyncio
from dataclasses import dataclass

@dataclass
class RateLimit:
    requests: int
    window_seconds: int
    burst_requests: int = None

class AdaptiveRateLimiter:
    def __init__(self, redis_client):
        self.redis = redis_client
        self.default_limits = {
            'user': RateLimit(1000, 3600, 50),      # 1000/hour, burst 50
            'api_key': RateLimit(10000, 3600, 200), # 10000/hour, burst 200
            'ip': RateLimit(100, 3600, 10)          # 100/hour, burst 10
        }

    async def check_rate_limit(self, identifier: str,
                              limit_type: str = 'user') -> dict:
        """Check if request is within rate limits"""

        limit = self.default_limits.get(limit_type)
        if not limit:
            return {'allowed': True}

        now = time.time()
        window_start = int(now // limit.window_seconds) * limit.window_seconds

        # Keys for tracking
        window_key = f"rate_limit:{identifier}:{window_start}"
        burst_key = f"rate_limit_burst:{identifier}"

        # Use Redis pipeline for atomic operations
        async with self.redis.pipeline() as pipe:
            pipe.incr(window_key)
            pipe.expire(window_key, limit.window_seconds)
            pipe.incr(burst_key)
            pipe.expire(burst_key, 60)  # 1-minute burst window

            results = await pipe.execute()

        window_count = results[0]
        burst_count = results[2]

        # Check limits
        window_exceeded = window_count > limit.requests
        burst_exceeded = (limit.burst_requests and
                         burst_count > limit.burst_requests)

        if window_exceeded or burst_exceeded:
            reset_time = window_start + limit.window_seconds
            return {
                'allowed': False,
                'limit': limit.requests,
                'remaining': max(0, limit.requests - window_count),
                'reset_time': reset_time,
                'retry_after': max(1, reset_time - now)
            }

        return {
            'allowed': True,
            'limit': limit.requests,
            'remaining': limit.requests - window_count,
            'reset_time': window_start + limit.window_seconds
        }

# Rate limiting middleware
@app.middleware("http")
async def rate_limiting_middleware(request: Request, call_next):
    # Skip rate limiting for health checks
    if request.url.path in ['/health', '/metrics']:
        return await call_next(request)

    # Determine rate limit identifier
    identifier = None
    limit_type = 'ip'

    # Check for API key
    api_key = request.headers.get('X-API-Key')
    if api_key:
        identifier = f"api_key:{api_key}"
        limit_type = 'api_key'
    else:
        # Check for authenticated user
        auth_header = request.headers.get('Authorization')
        if auth_header and auth_header.startswith('Bearer '):
            try:
                token = auth_header.split(' ')[1]
                payload = jwt.decode(token, verify=False)  # Just for rate limiting
                identifier = f"user:{payload.get('user_id')}"
                limit_type = 'user'
            except:
                pass

    # Fall back to IP-based limiting
    if not identifier:
        # Get real IP (considering proxies)
        ip = request.headers.get('X-Forwarded-For', '').split(',')[0].strip()
        if not ip:
            ip = request.headers.get('X-Real-IP', '')
        if not ip:
            ip = request.client.host
        identifier = f"ip:{ip}"

    # Check rate limit
    rate_limiter = get_rate_limiter()
    result = await rate_limiter.check_rate_limit(identifier, limit_type)

    if not result['allowed']:
        return JSONResponse(
            status_code=429,
            content={
                "error": "Rate limit exceeded",
                "retry_after": result['retry_after']
            },
            headers={
                "X-RateLimit-Limit": str(result['limit']),
                "X-RateLimit-Remaining": "0",
                "X-RateLimit-Reset": str(int(result['reset_time'])),
                "Retry-After": str(int(result['retry_after']))
            }
        )

    # Continue with request
    response = await call_next(request)

    # Add rate limit headers to response
    if 'limit' in result:
        response.headers["X-RateLimit-Limit"] = str(result['limit'])
        response.headers["X-RateLimit-Remaining"] = str(result['remaining'])
        response.headers["X-RateLimit-Reset"] = str(int(result['reset_time']))

    return response
                        </pre>
                    </div>
                </section>

                <section class="next-steps">
                    <h2>Next Steps</h2>
                    <p>To explore related API design and architecture topics:</p>
                    <ol>
                        <li><strong><a href="websocket-protocol.html">WebSocket Protocol</a>:</strong> Real-time communication complementing the REST API</li>
                        <li><strong><a href="database-schema.html">Database Schema</a>:</strong> Data models that support the API operations</li>
                        <li><strong><a href="performance-metrics.html">Performance Metrics</a>:</strong> API performance monitoring and optimization</li>
                        <li><strong><a href="design-principles.html">Design Principles</a>:</strong> Architectural patterns behind the API design</li>
                        <li><strong><a href="scaling-strategies.html">Scaling Strategies</a>:</strong> Scale API infrastructure for high loads</li>
                    </ol>
                </section>
            </div>

            <div class="docs-footer">
                <div class="docs-navigation">
                    <h3>Navigation</h3>
                    <div class="nav-links">
                        <a href="performance-metrics.html" class="nav-link">â† Performance Metrics</a>
                        <a href="./" class="nav-link">Architecture Home â†’</a>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer class="site-footer">
        <div class="container">
            <div class="footer-bottom">
                <p>&copy; 2024 SysManage. All rights reserved.</p>
            </div>
        </div>
    </footer>

    <script src="../../assets/js/navbar.js"></script>
    <script src="../../assets/js/main.js"></script>
    <script src="../../assets/js/i18n.js"></script>
</body>
</html>