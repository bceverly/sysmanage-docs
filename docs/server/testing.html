<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Testing - SysManage Server</title>
    <meta name="description" content="Comprehensive testing guide for SysManage including unit tests, integration tests, and E2E testing with Playwright.">
    <link rel="stylesheet" href="../../assets/css/style.css">
    <link rel="icon" type="image/svg+xml" href="../../assets/images/favicon.svg">
</head>
<body>
    <header class="site-header">
        <nav class="navbar">
            <div class="container">
                <div class="nav-brand">
                    <a href="../../">
                        <img src="../../assets/images/sysmanage-logo.svg" alt="SysManage" class="logo">
                    </a>
                </div>
                <div class="nav-menu">
                    <a href="../../#features" class="nav-link" data-i18n="nav.features">Features</a>
                    <a href="../../#getting-started" class="nav-link" data-i18n="nav.getting_started">Getting Started</a>
                    <a href="../" class="nav-link active" data-i18n="nav.documentation">Documentation</a>
                    <a href="../../config-builder.html" class="nav-link" data-i18n="nav.config_builder">Configuration Builder</a>
                    <a href="https://github.com/bceverly/sysmanage" class="nav-link" target="_blank" data-i18n="nav.github">GitHub</a>
                </div>
            </div>
        </nav>
    </header>

    <main class="docs-main">
        <div class="container">
            <div class="docs-breadcrumb">
                <a href="../">Documentation</a> > <a href="./">Server</a> > <span>Testing</span>
            </div>

            <div class="docs-header">
                <h1>Testing</h1>
                <p>Comprehensive testing strategy for SysManage server including unit tests, integration tests, and end-to-end testing with Playwright.</p>
            </div>

            <div class="docs-content">
                <section class="docs-overview">
                    <h2 data-i18n="testing.overview.title">Testing Strategy Overview</h2>
                    <p data-i18n="testing.overview.description">SysManage employs a multi-layered testing approach to ensure reliability, security, and functionality across all components:</p>

                    <div class="testing-layers">
                        <div class="testing-layer">
                            <h3>üß™ <span data-i18n="testing.overview.unit.title">Unit Tests</span></h3>
                            <p data-i18n="testing.overview.unit.description">Comprehensive unit testing for individual components and functions</p>
                            <ul>
                                <li><strong data-i18n="testing.overview.unit.backend">Backend:</strong> <span data-i18n="testing.overview.unit.backend.count">1,432 Python tests using pytest</span></li>
                                <li><strong data-i18n="testing.overview.unit.frontend">Frontend:</strong> <span data-i18n="testing.overview.unit.frontend.count">63 TypeScript tests using Vitest</span></li>
                                <li><strong data-i18n="testing.overview.unit.coverage">Coverage:</strong> <span data-i18n="testing.overview.unit.coverage.value">100% test coverage for both backend and frontend</span></li>
                            </ul>
                        </div>
                        <div class="testing-layer">
                            <h3>üîó <span data-i18n="testing.overview.integration.title">Integration Tests</span></h3>
                            <p data-i18n="testing.overview.integration.description">Testing interactions between different system components</p>
                            <ul>
                                <li data-i18n="testing.overview.integration.api">API endpoint testing</li>
                                <li data-i18n="testing.overview.integration.database">Database integration testing</li>
                                <li data-i18n="testing.overview.integration.websocket">WebSocket communication testing</li>
                                <li data-i18n="testing.overview.integration.auth">Authentication and authorization flow testing</li>
                            </ul>
                        </div>
                        <div class="testing-layer">
                            <h3>üé≠ <span data-i18n="testing.overview.e2e.title">End-to-End (E2E) Tests</span></h3>
                            <p data-i18n="testing.overview.e2e.description">Complete user workflow testing using Playwright</p>
                            <ul>
                                <li data-i18n="testing.overview.e2e.journey">Full user journey testing</li>
                                <li data-i18n="testing.overview.e2e.crossbrowser">Cross-browser compatibility</li>
                                <li data-i18n="testing.overview.e2e.realworld">Real-world scenario validation</li>
                                <li data-i18n="testing.overview.e2e.ui">UI interaction and workflow testing</li>
                            </ul>
                        </div>
                        <div class="testing-layer">
                            <h3>üéØ <span data-i18n="testing.overview.msw.title">Mock Service Worker (MSW)</span></h3>
                            <p data-i18n="testing.overview.msw.description">API mocking for isolated and reliable frontend testing</p>
                            <ul>
                                <li data-i18n="testing.overview.msw.isolation">Complete test isolation from backend dependencies</li>
                                <li data-i18n="testing.overview.msw.speed">Faster test execution without network requests</li>
                                <li data-i18n="testing.overview.msw.reliability">Consistent and predictable test behavior</li>
                                <li data-i18n="testing.overview.msw.realistic">Realistic API response simulation</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <section class="docs-section">
                    <h2 data-i18n="testing.running.title">Running Tests</h2>

                    <h3 data-i18n="testing.running.all.title">All Tests</h3>
                    <div class="code-block">
                        <pre><code># Run complete test suite
make test

# Run tests with coverage reporting
make test-coverage</code></pre>
                    </div>

                    <h3 data-i18n="testing.running.backend.title">Backend Tests (Python/pytest)</h3>
                    <div class="code-block">
                        <pre><code># Run all backend tests
python -m pytest tests/ -v

# Run specific test file
python -m pytest tests/test_api_hosts.py -v

# Run with coverage
python -m pytest tests/ --cov=backend --cov-report=html

# Run only unit tests
python -m pytest tests/ -m "not integration"

# Run only integration tests
python -m pytest tests/ -m integration</code></pre>
                    </div>

                    <h3 data-i18n="testing.running.frontend.title">Frontend Tests (TypeScript/Vitest with MSW)</h3>
                    <p data-i18n="testing.running.frontend.description">Frontend tests automatically use Mock Service Worker for API mocking:</p>
                    <div class="code-block">
                        <pre><code># Run all frontend tests (with MSW automatically active)
cd frontend && npm test

# Run tests in watch mode
cd frontend && npm run test:watch

# Run with coverage
cd frontend && npm run test:coverage

# Run specific test file
cd frontend && npm test -- src/__tests__/Pages/Reports.test.tsx

# View MSW request logs in tests
cd frontend && npm test -- --reporter=verbose</code></pre>
                    </div>

                    <div class="info-box">
                        <h4>üéØ <span data-i18n="testing.running.frontend.msw.title">MSW Behavior</span></h4>
                        <p data-i18n="testing.running.frontend.msw.description">When running frontend tests:</p>
                        <ul>
                            <li data-i18n="testing.running.frontend.msw.automatic">MSW automatically intercepts all API requests</li>
                            <li data-i18n="testing.running.frontend.msw.logging">Request logs appear in console output</li>
                            <li data-i18n="testing.running.frontend.msw.isolation">Each test runs in complete isolation</li>
                            <li data-i18n="testing.running.frontend.msw.realistic">Realistic API responses are provided automatically</li>
                        </ul>
                    </div>

                    <h3 data-i18n="testing.running.e2e.title">End-to-End Tests (Playwright)</h3>
                    <div class="code-block">
                        <pre><code># Install Playwright (if not already installed)
pip install playwright
npx playwright install

# Run E2E tests
npm run test:e2e

# Run E2E tests in specific browser
npx playwright test --project=chromium
npx playwright test --project=firefox
npx playwright test --project=webkit

# Run E2E tests in headed mode (visible browser)
npx playwright test --headed

# Debug E2E tests
npx playwright test --debug</code></pre>
                    </div>
                </section>

                <section class="docs-section">
                    <h2 data-i18n="testing.msw.title">Mock Service Worker (MSW) Frontend Testing</h2>

                    <h3 data-i18n="testing.msw.overview.title">Overview</h3>
                    <p data-i18n="testing.msw.overview.description">Mock Service Worker (MSW) is a powerful API mocking library that intercepts HTTP requests at the network level, providing realistic API responses for frontend testing. SysManage uses MSW extensively to ensure frontend components can be tested in isolation without requiring a running backend server.</p>

                    <div class="info-box">
                        <h4>üí° <span data-i18n="testing.msw.benefits.title">Why MSW?</span></h4>
                        <ul>
                            <li data-i18n="testing.msw.benefits.isolation"><strong>Test Isolation:</strong> Frontend tests run independently of backend availability</li>
                            <li data-i18n="testing.msw.benefits.speed"><strong>Performance:</strong> No network latency, tests execute faster</li>
                            <li data-i18n="testing.msw.benefits.reliability"><strong>Reliability:</strong> Consistent responses eliminate flaky tests</li>
                            <li data-i18n="testing.msw.benefits.development"><strong>Development:</strong> Work on frontend features before backend APIs are ready</li>
                            <li data-i18n="testing.msw.benefits.cicd"><strong>CI/CD:</strong> No need to spin up backend services in test environments</li>
                        </ul>
                    </div>

                    <h3 data-i18n="testing.msw.installation.title">Installation & Configuration</h3>
                    <p data-i18n="testing.msw.installation.description">MSW is already installed and configured in the SysManage frontend. The setup includes:</p>

                    <div class="code-block">
                        <pre><code># MSW installation
npm install --save-dev msw@^2.11.3

# MSW configuration in package.json
{
  "msw": {
    "workerDirectory": ["public"]
  }
}</code></pre>
                    </div>

                    <h3 data-i18n="testing.msw.implementation.title">Implementation Architecture</h3>

                    <h4 data-i18n="testing.msw.handlers.title">Request Handlers</h4>
                    <p data-i18n="testing.msw.handlers.description">MSW handlers are defined in <code>/src/mocks/handlers.ts</code> and provide comprehensive API coverage:</p>

                    <div class="code-block">
                        <pre><code>// /src/mocks/handlers.ts
import { http, HttpResponse } from 'msw';

export const handlers = [
  // Catch all /api/ requests and handle them dynamically
  http.get('http://localhost:8080/api/*', ({ request }) => {
    const url = new globalThis.URL(request.url);
    const path = url.pathname;

    // Host data endpoint
    if (path === '/api/host/1' || path === '/api/hosts/1') {
      return HttpResponse.json({
        id: 1,
        fqdn: 'test-host.example.com',
        ipv4: '192.168.1.100',
        active: true,
        status: 'up',
        platform: 'Linux',
        // ... complete host data
      });
    }

    // Package search with query parameter handling
    if (path === '/api/packages/search') {
      const query = url.searchParams.get('query');
      if (!query || query.length < 2) {
        return HttpResponse.json([]);
      }

      const results = availablePackages.filter(pkg =>
        pkg.name.toLowerCase().includes(query.toLowerCase())
      );
      return HttpResponse.json(results);
    }

    // Default response for unmatched endpoints
    return HttpResponse.json([]);
  }),

  // POST endpoints for package management
  http.post('http://localhost:8080/api/packages/install/*', async ({ request }) => {
    const body = await request.json();
    return HttpResponse.json({
      success: true,
      message: 'Package installation has been queued',
      installation_ids: body.package_names.map(() => `uuid-${Math.random()}`)
    });
  }),
];</code></pre>
                    </div>

                    <h4 data-i18n="testing.msw.server.title">Test Server Setup</h4>
                    <p data-i18n="testing.msw.server.description">The MSW server is configured for Node.js test environments in <code>/src/mocks/node.ts</code>:</p>

                    <div class="code-block">
                        <pre><code>// /src/mocks/node.ts
import { setupServer } from 'msw/node';
import { handlers } from './handlers';

// Setup MSW server for Node.js environment (tests)
export const server = setupServer(...handlers);</code></pre>
                    </div>

                    <h4 data-i18n="testing.msw.integration.title">Test Integration</h4>
                    <p data-i18n="testing.msw.integration.description">MSW is automatically configured for all tests in <code>/src/setupTests.ts</code> with proper lifecycle management:</p>

                    <div class="code-block">
                        <pre><code>// /src/setupTests.ts
import { beforeAll, afterEach, afterAll } from 'vitest';
import { server } from './mocks/node';

// Start MSW server before all tests
beforeAll(() => {
  server.listen({
    onUnhandledRequest: 'warn', // Warn about unhandled requests
  });

  if (process.env.CI === 'true') {
    console.log('üöÄ MSW server started for CI environment');
  }
});

// Reset handlers after each test for isolation
afterEach(() => {
  server.resetHandlers();
});

// Clean up after all tests
afterAll(() => {
  server.close();
});</code></pre>
                    </div>

                    <h3 data-i18n="testing.msw.features.title">Key Features</h3>

                    <h4 data-i18n="testing.msw.features.dynamic.title">Dynamic Path Handling</h4>
                    <p data-i18n="testing.msw.features.dynamic.description">MSW uses broad pattern matching with dynamic path resolution:</p>
                    <ul>
                        <li data-i18n="testing.msw.features.dynamic.wildcard">Wildcard patterns catch all <code>/api/*</code> requests</li>
                        <li data-i18n="testing.msw.features.dynamic.parsing">URL parsing extracts specific endpoint paths</li>
                        <li data-i18n="testing.msw.features.dynamic.fallback">Graceful fallback for unmatched endpoints</li>
                    </ul>

                    <h4 data-i18n="testing.msw.features.realistic.title">Realistic Response Simulation</h4>
                    <p data-i18n="testing.msw.features.realistic.description">MSW provides comprehensive mock data that mirrors real API responses:</p>
                    <ul>
                        <li data-i18n="testing.msw.features.realistic.hosts">Complete host information with hardware details</li>
                        <li data-i18n="testing.msw.features.realistic.users">User authentication and profile data</li>
                        <li data-i18n="testing.msw.features.realistic.packages">Software package data with search functionality</li>
                        <li data-i18n="testing.msw.features.realistic.operations">Package installation/uninstallation operations</li>
                    </ul>

                    <h4 data-i18n="testing.msw.features.ci.title">CI/CD Integration</h4>
                    <p data-i18n="testing.msw.features.ci.description">MSW includes special handling for continuous integration environments:</p>
                    <div class="code-block">
                        <pre><code>// Enhanced logging for CI environments
const logPrefix = process.env.CI === 'true' ? 'üîÑ MSW-CI:' : 'MSW:';
console.log(`${logPrefix} Handling GET ${path}`);

// CI-specific startup and shutdown messages
if (process.env.CI === 'true') {
  console.log('üöÄ MSW server started for CI environment');
}</code></pre>
                    </div>

                    <h3 data-i18n="testing.msw.usage.title">Usage in Tests</h3>

                    <h4 data-i18n="testing.msw.usage.automatic.title">Automatic API Mocking</h4>
                    <p data-i18n="testing.msw.usage.automatic.description">Most tests automatically benefit from MSW without additional configuration:</p>
                    <div class="code-block">
                        <pre><code>// Test automatically uses MSW for API calls
test('renders host information', async () => {
  render(<HostDetail hostId={1} />);

  // MSW automatically returns mock host data
  await waitFor(() => {
    expect(screen.getByText('test-host.example.com')).toBeInTheDocument();
    expect(screen.getByText('192.168.1.100')).toBeInTheDocument();
  });
});</code></pre>
                    </div>

                    <h4 data-i18n="testing.msw.usage.custom.title">Custom Handler Overrides</h4>
                    <p data-i18n="testing.msw.usage.custom.description">Tests can override specific handlers for custom scenarios:</p>
                    <div class="code-block">
                        <pre><code>import { server } from '../../mocks/node';
import { http, HttpResponse } from 'msw';

test('handles API error gracefully', async () => {
  // Override handler for this test
  server.use(
    http.get('http://localhost:8080/api/host/1', () => {
      return HttpResponse.json(
        { error: 'Host not found' },
        { status: 404 }
      );
    })
  );

  render(<HostDetail hostId={1} />);

  await waitFor(() => {
    expect(screen.getByText('Error loading host')).toBeInTheDocument();
  });
});</code></pre>
                    </div>

                    <h3 data-i18n="testing.msw.compatibility.title">React 19 Compatibility</h3>
                    <p data-i18n="testing.msw.compatibility.description">SysManage includes special compatibility fixes for React 19 in the test environment:</p>
                    <div class="code-block">
                        <pre><code>// React 19 compatibility fixes in setupTests.ts
globalThis.IS_REACT_ACT_ENVIRONMENT = true;

// Scheduler polyfills for React 19
Object.defineProperty(globalThis, 'Scheduler', {
  value: {
    unstable_scheduleCallback: (callback) => setTimeout(callback, 0),
    unstable_cancelCallback: () => {},
    unstable_shouldYield: () => false,
    // ... additional React 19 compatibility
  }
});</code></pre>
                    </div>

                    <h3 data-i18n="testing.msw.bestpractices.title">Best Practices</h3>
                    <ul>
                        <li data-i18n="testing.msw.bestpractices.isolation"><strong>Test Isolation:</strong> MSW automatically resets handlers between tests</li>
                        <li data-i18n="testing.msw.bestpractices.realistic"><strong>Realistic Data:</strong> Use mock data that closely matches production API responses</li>
                        <li data-i18n="testing.msw.bestpractices.coverage"><strong>API Coverage:</strong> Ensure all API endpoints used by components are mocked</li>
                        <li data-i18n="testing.msw.bestpractices.errors"><strong>Error Scenarios:</strong> Test both success and error responses</li>
                        <li data-i18n="testing.msw.bestpractices.logging"><strong>Request Logging:</strong> Use MSW logging to debug unexpected API calls</li>
                    </ul>

                    <div class="info-box">
                        <h4>üîç <span data-i18n="testing.msw.debugging.title">Debugging MSW</span></h4>
                        <p data-i18n="testing.msw.debugging.description">If tests fail due to API issues, check:</p>
                        <ul>
                            <li data-i18n="testing.msw.debugging.console">Console output for MSW request logs</li>
                            <li data-i18n="testing.msw.debugging.unhandled">Warnings about unhandled requests</li>
                            <li data-i18n="testing.msw.debugging.handlers">Handler patterns match actual API calls</li>
                            <li data-i18n="testing.msw.debugging.setup">MSW server is properly started in test setup</li>
                        </ul>
                    </div>
                </section>

                <section class="docs-section">
                    <h2>Playwright E2E Testing</h2>

                    <h3>Overview</h3>
                    <p>Playwright provides comprehensive end-to-end testing capabilities for SysManage, allowing you to test complete user workflows across different browsers and platforms.</p>

                    <h3>Installation & Setup</h3>
                    <div class="code-block">
                        <pre><code># Install Playwright
npm install -D @playwright/test

# Install browser binaries
npx playwright install

# Install system dependencies (Linux)
npx playwright install-deps</code></pre>
                    </div>

                    <div class="info-box">
                        <h4>üí° Platform Compatibility</h4>
                        <p>Playwright may not be available on all platforms. For example, it's currently not supported on OpenBSD. In such cases, manual testing or alternative tools should be used.</p>
                    </div>

                    <h3>Configuration</h3>
                    <p>Playwright configuration is defined in <code>playwright.config.ts</code>:</p>
                    <div class="code-block">
                        <pre><code>import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
  ],
  webServer: {
    command: 'npm run start',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
  },
});</code></pre>
                    </div>

                    <h3>Example E2E Test</h3>
                    <div class="code-block">
                        <pre><code>// e2e/login-workflow.spec.ts
import { test, expect } from '@playwright/test';

test('user can login and access dashboard', async ({ page }) => {
  // Navigate to login page
  await page.goto('/login');

  // Fill login form
  await page.fill('[data-testid=username]', 'admin@example.com');
  await page.fill('[data-testid=password]', 'password123');

  // Submit form
  await page.click('[data-testid=login-button]');

  // Verify successful login
  await expect(page).toHaveURL('/dashboard');
  await expect(page.locator('h1')).toContainText('Dashboard');
});

test('user can generate reports', async ({ page }) => {
  // Login first
  await page.goto('/login');
  await page.fill('[data-testid=username]', 'admin@example.com');
  await page.fill('[data-testid=password]', 'password123');
  await page.click('[data-testid=login-button]');

  // Navigate to reports
  await page.click('text=Reports');
  await expect(page).toHaveURL('/reports');

  // Generate PDF report
  await page.click('text=Generate PDF');

  // Wait for download
  const downloadPromise = page.waitForEvent('download');
  const download = await downloadPromise;

  // Verify download
  expect(download.suggestedFilename()).toContain('.pdf');
});</code></pre>
                    </div>

                    <h3>Best Practices</h3>
                    <ul>
                        <li><strong>Data Attributes:</strong> Use <code>data-testid</code> attributes for reliable element selection</li>
                        <li><strong>Page Object Model:</strong> Organize tests using page objects for maintainability</li>
                        <li><strong>Test Isolation:</strong> Ensure tests are independent and can run in any order</li>
                        <li><strong>Wait Strategies:</strong> Use appropriate wait strategies for dynamic content</li>
                        <li><strong>Screenshots:</strong> Enable screenshots on failure for debugging</li>
                        <li><strong>Cross-browser:</strong> Run tests across multiple browsers to ensure compatibility</li>
                    </ul>
                </section>

                <section class="docs-section">
                    <h2>Test Coverage</h2>

                    <h3>Coverage Reports</h3>
                    <p>SysManage maintains comprehensive test coverage across all layers:</p>

                    <div class="coverage-stats">
                        <div class="coverage-item">
                            <h4>Backend Coverage</h4>
                            <div class="coverage-bar">
                                <div class="coverage-fill" style="width: 100%;">100%</div>
                            </div>
                            <p>1,432 Python tests covering API endpoints, business logic, and database operations</p>
                        </div>
                        <div class="coverage-item">
                            <h4>Frontend Coverage</h4>
                            <div class="coverage-bar">
                                <div class="coverage-fill" style="width: 100%;">100%</div>
                            </div>
                            <p>63 TypeScript tests covering React components, services, and utilities</p>
                        </div>
                    </div>

                    <h3>Generating Coverage Reports</h3>
                    <div class="code-block">
                        <pre><code># Backend coverage (HTML report)
python -m pytest tests/ --cov=backend --cov-report=html
open htmlcov/index.html

# Frontend coverage
cd frontend && npm run test:coverage
open coverage/index.html

# Combined coverage reporting
make test-coverage</code></pre>
                    </div>
                </section>

                <section class="docs-section">
                    <h2>Continuous Integration</h2>

                    <h3>GitHub Actions</h3>
                    <p>All tests run automatically in the CI/CD pipeline:</p>
                    <div class="code-block">
                        <pre><code>name: CI/CD Pipeline
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          cd frontend && npm install

      - name: Run backend tests
        run: python -m pytest tests/ --cov=backend

      - name: Run frontend tests
        run: cd frontend && npm test

      - name: Install Playwright
        run: npx playwright install --with-deps

      - name: Run E2E tests
        run: npm run test:e2e</code></pre>
                    </div>
                </section>

                <section class="docs-section">
                    <h2>Testing Different Components</h2>

                    <h3>API Endpoints</h3>
                    <p>Test API endpoints using pytest with FastAPI's test client:</p>
                    <div class="code-block">
                        <pre><code>def test_get_hosts(authenticated_client):
    response = authenticated_client.get("/api/hosts")
    assert response.status_code == 200
    assert "hosts" in response.json()

def test_create_host(authenticated_client):
    host_data = {
        "fqdn": "test.example.com",
        "active": True
    }
    response = authenticated_client.post("/api/hosts", json=host_data)
    assert response.status_code == 201</code></pre>
                    </div>

                    <h3>React Components</h3>
                    <p>Test React components using Vitest and React Testing Library:</p>
                    <div class="code-block">
                        <pre><code>import { render, screen, fireEvent } from '@testing-library/react';
import { vi } from 'vitest';
import Reports from '../Pages/Reports';

test('generates PDF when button clicked', async () => {
  const mockApi = vi.mocked(api);
  mockApi.get.mockResolvedValue({
    data: new Blob(['pdf'], { type: 'application/pdf' })
  });

  render(<Reports />);

  const generateButton = screen.getByText('Generate PDF');
  fireEvent.click(generateButton);

  await waitFor(() => {
    expect(mockApi.get).toHaveBeenCalledWith(
      '/api/reports/generate/hosts',
      expect.objectContaining({ responseType: 'blob' })
    );
  });
});</code></pre>
                    </div>

                    <h3>WebSocket Communication</h3>
                    <p>Test WebSocket connections and message handling:</p>
                    <div class="code-block">
                        <pre><code>def test_websocket_connection(client):
    with client.websocket_connect("/ws") as websocket:
        websocket.send_text("ping")
        data = websocket.receive_text()
        assert data == "pong"</code></pre>
                    </div>
                </section>

                <section class="docs-section">
                    <h2>Troubleshooting Tests</h2>

                    <h3>Common Issues</h3>

                    <div class="troubleshooting-item">
                        <h4>Playwright Installation Fails</h4>
                        <p><strong>Problem:</strong> Browser binaries fail to install</p>
                        <p><strong>Solution:</strong> Install system dependencies: <code>npx playwright install-deps</code></p>
                    </div>

                    <div class="troubleshooting-item">
                        <h4>Tests Fail in CI but Pass Locally</h4>
                        <p><strong>Problem:</strong> Environment differences between local and CI</p>
                        <p><strong>Solution:</strong> Check for timing issues, use proper wait strategies, ensure consistent test data</p>
                    </div>

                    <div class="troubleshooting-item">
                        <h4>Frontend Tests Can't Find Elements</h4>
                        <p><strong>Problem:</strong> React components not rendering properly in tests</p>
                        <p><strong>Solution:</strong> Use <code>await waitFor()</code> for async operations, check component mocking</p>
                    </div>

                    <div class="troubleshooting-item">
                        <h4>Database Tests Interfere with Each Other</h4>
                        <p><strong>Problem:</strong> Test database state affects other tests</p>
                        <p><strong>Solution:</strong> Use database transactions and rollback, or isolated test databases</p>
                    </div>

                    <h3>Debug Mode</h3>
                    <div class="code-block">
                        <pre><code># Debug backend tests
python -m pytest tests/test_specific.py -v -s --pdb

# Debug frontend tests
cd frontend && npm test -- --run=false

# Debug Playwright tests
npx playwright test --debug</code></pre>
                    </div>
                </section>

                <section class="docs-section">
                    <h2>Performance Testing</h2>

                    <p>While not part of the standard test suite, consider these tools for performance testing:</p>

                    <h3>Load Testing</h3>
                    <ul>
                        <li><strong>Locust:</strong> Python-based load testing for API endpoints</li>
                        <li><strong>Artillery:</strong> Modern load testing toolkit</li>
                        <li><strong>JMeter:</strong> Traditional load testing solution</li>
                    </ul>

                    <h3>Frontend Performance</h3>
                    <ul>
                        <li><strong>Lighthouse:</strong> Web performance auditing</li>
                        <li><strong>WebPageTest:</strong> Detailed performance analysis</li>
                        <li><strong>Playwright Performance:</strong> Performance metrics collection during E2E tests</li>
                    </ul>
                </section>
            </div>
        </div>
    </main>

    <footer class="site-footer">
        <div class="container">
            <p>&copy; 2024 SysManage. Licensed under AGPLv3.</p>
        </div>
    </footer>

    <script src="../../assets/js/i18n.js"></script>
    <script src="../../assets/js/main.js"></script>
    <script src="../../assets/js/navbar.js"></script>
    <script src="../../assets/js/main.js"></script>
    <script src="../../assets/js/i18n.js"></script>
</body>
</html>